[{"categories":null,"contents":"","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/basic/_index.bn/","summary":"","tags":null,"title":"Go বেসিক"},{"categories":null,"contents":" Hello World A sample go program is show here.\npackage main import \u0026#34;fmt\u0026#34; func main() { message := greetMe(\u0026#34;world\u0026#34;) fmt.Println(message) } func greetMe(name string) string { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; } Run the program as below:\n$ go run hello.go Variables Normal Declaration:\nvar msg string msg = \u0026#34;Hello\u0026#34; Shortcut:\nmsg := \u0026#34;Hello\u0026#34; Constants const Phi = 1.618 ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/basic/introduction/","summary":" Hello World A sample go program is show here.\npackage main import \u0026#34;fmt\u0026#34; func main() { message := greetMe(\u0026#34;world\u0026#34;) fmt.Println(message) } func greetMe(name string) string { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34; } Run the program as below:\n$ go run hello.go Variables Normal Declaration:\nvar msg string msg = \u0026#34;Hello\u0026#34; Shortcut:\nmsg := \u0026#34;Hello\u0026#34; Constants const Phi = 1.618 ","tags":null,"title":"Introduction"},{"categories":null,"contents":" Strings str := \u0026#34;Hello\u0026#34; Multiline string\nstr := `Multiline string` Numbers Typical types\nnum := 3 // int num := 3. // float64 num := 3 + 4i // complex128 num := byte(\u0026#39;a\u0026#39;) // byte (alias for uint8) Other Types\nvar u uint = 7 // uint (unsigned) var p float32 = 22.7 // 32-bit float Arrays // var numbers [5]int numbers := [...]int{0, 0, 0, 0, 0} Pointers func main () { b := *getPointer() fmt.Println(\u0026#34;Value is\u0026#34;, b) func getPointer () (myPointer *int) { a := 234 return \u0026amp;a a := new(int) *a = 234 Pointers point to a memory location of a variable. Go is fully garbage-collected.\nType Conversion i := 2 f := float64(i) u := uint(i) Slice slice := []int{2, 3, 4} slice := []byte(\u0026#34;Hello\u0026#34;) ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/basic/types/","summary":"Strings str := \u0026#34;Hello\u0026#34; Multiline string\nstr := `Multiline string` Numbers Typical types\nnum := 3 // int num := 3. // float64 num := 3 + 4i // complex128 num := byte(\u0026#39;a\u0026#39;) // byte (alias for uint8) Other Types\nvar u uint = 7 // uint (unsigned) var p float32 = 22.7 // 32-bit float Arrays // var numbers [5]int numbers := [...]int{0, 0, 0, 0, 0} Pointers func main () { b := *getPointer() fmt.","tags":null,"title":"Basic Types"},{"categories":null,"contents":"","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/advanced/_index.bn/","summary":"","tags":null,"title":"অ্যাডভান্সড"},{"categories":null,"contents":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) Switch switch day { case \u0026#34;sunday\u0026#34;: // cases don\u0026#39;t \u0026#34;fall through\u0026#34; by default! fallthrough case \u0026#34;saturday\u0026#34;: rest() default: work() } Loop for count := 0; count \u0026lt;= 10; count++ { fmt.Println(\u0026#34;My counter is at\u0026#34;, count) } entry := []string{\u0026#34;Jack\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Jones\u0026#34;} for i, val := range entry { fmt.Printf(\u0026#34;At position %d, the character %s is present\\n\u0026#34;, i, val) n := 0 x := 42 for n != x { n := guess() } ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/basic/flow-control/","summary":"Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) Switch switch day { case \u0026#34;sunday\u0026#34;: // cases don\u0026#39;t \u0026#34;fall through\u0026#34; by default! fallthrough case \u0026#34;saturday\u0026#34;: rest() default: work() } Loop for count := 0; count \u0026lt;= 10; count++ { fmt.Println(\u0026#34;My counter is at\u0026#34;, count) } entry := []string{\u0026#34;Jack\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Jones\u0026#34;} for i, val := range entry { fmt.","tags":null,"title":"Flow Control"},{"categories":null,"contents":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/advanced/files/","summary":" Condition if day == \u0026#34;sunday\u0026#34; || day == \u0026#34;saturday\u0026#34; { rest() } else if day == \u0026#34;monday\u0026#34; \u0026amp;\u0026amp; isTired() { groan() } else { work() } if _, err := doThing(); err != nil { fmt.Println(\u0026#34;Uh oh\u0026#34;) ","tags":null,"title":"File Manipulation"},{"categories":null,"contents":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/bash/basic/","summary":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","tags":null,"title":"Bash Variables"},{"categories":null,"contents":"In this post I\u0026rsquo;d like to show you how to integrate a custom Microsoft Copilot Studio Chatbot with MkDocs. The goal is to provide a chatbot on all pages of the documentation, that is trained with the content of the documentation, see screenshot.\nAbout this Approach You can connect to a copilot with a custom canvas that is hosted as a standalone web app in your MkDocs project. This option is best if you need to embed a customized iFrame across multiple web pages / documentation pages. Note that the depicted example uses the Material theme and integrates the chatbot by extending the theme.\nThis post also covers the following customizations to the chatbot`s look and feel:\nchange the text displayed in the banner change the color of the banner add a close button to the banner add a scaler to the banner (upper left corner) to resize the chatbot add a button to open the chatbot on multiple documentation pages Default Chatbot:\nCustomized Chatbot:\nSetup in Copilot Studio Create a new Copilot chatbot in Copilot Studio, see Microsoft Documentation: Create and Deploy a Copilot Studio Copilot. Train the Copilot with your published MkDocs website. Note that there are requirements for some URLs, see Microsoft Documentation: URL type and structure. Optional: Customize Icons, answers, etc, see Microsoft Documentation: Change the copilot name and icon. Thoroughly test your chatbot in Copilot Studio. Publish the chatbot, see Microsoft Documentation: Publish your Copilot. Copy the token endpoint of your chatbot, see Microsoft Documentation: Retrieve token endpoint. The token is needed to integrate the chatbot to your website. You can add the created chatbot as-is to your website using a simple code snippet, see Microsoft Documentation: Add your Copilot to your Website. To further customize the chatbot and add buttons to open and close the chatbot to your website, follow the instructions in the next paragraph.\nIntegrate the Chatbot To customize the default chatbot, we connect the copilot with a custom canvas that is hosted as a standalone web app.\nCopy and paste the HTML code provided by the Microsoft Documentation: Customize the Default Canvas and save it as a chatbot.html file in the /docs directory of your MkDocs project.\nOpen the chatbot.html file and replace \u0026lt;COPILOT TOKEN ENDPOINT\u0026gt; with your token endpoint, see Setup in Copilot Studio.\nconst tokenEndpointURL = new URL(\u0026#39;\u0026lt;COPILOT TOKEN ENDPOINT\u0026gt;\u0026#39;); Delete the following lines to remove the banner from the chatbot:\n\u0026lt;div id=\u0026#34;banner\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Contoso copilot name\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; This removes the banner from the chatbot. We will create our own banner that includes a scaling option and a close button later.\nTest the chatbot integration (token endpoint) by serving the project. You should be able to access and interact with the chatbot via http://localhost:8000/chatbot.html.\nIf the chatbot works as expected, publish your MkDocs project. This step is necessary to make the custom canvas accessible online.\nIf it does not exist yet, create a folder /overrides in the root directory of your MkDocs project and create a file main.html, see Material: Extending the Theme.\nAdding the chatbot in main.html makes the chatbot available on all pages of the documentation. Alternatively, create a new html template that you can assign to specific pages. Copy and paste the following code into main.html:\n{% extends \u0026#34;base.html\u0026#34; %} {% block extrahead %} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#39;assets/stylesheets/chatbot.css\u0026#39; | url }}\u0026#34;\u0026gt; {% endblock %} {% block scripts %} {{ super() }} \u0026lt;script src=\u0026#34;{{ \u0026#39;assets/javascripts/chatbot.js\u0026#39; | url }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {% endblock %} {% block content %} {{ super() }} \u0026lt;!-- Open Chatbot button --\u0026gt; \u0026lt;button class=\u0026#34;btn-clear md-button\u0026#34; title=\u0026#34;Open Chatbot\u0026#34; id=\u0026#34;open_button\u0026#34; onclick=\u0026#34;openChatbot()\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;twemoji\u0026#34; style=\u0026#34;font-size: 35px\u0026#34;;\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;fa-beat\u0026#34; style=\u0026#34;margin-top: -5px;\u0026#34;\u0026gt;{% include \u0026#34;.icons/fontawesome/solid/comments.svg\u0026#34; %} \u0026lt;/div\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- Chatbot Container --\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;chatbot_iframe\u0026#34; src=\u0026#34;https://your-documentation.com/chatbot.html\u0026#34; frameborder=\u0026#34;1\u0026#34; style=\u0026#34;width: 100%; height: 100%;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;div id=\u0026#34;resize-handler\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;banner\u0026#34;\u0026#34;\u0026gt; \u0026lt;p style=\u0026#34;font-family: inherit; font-size: 16px; color: white; line-height: 20px; position: absolute; left: 15px;\u0026#34;\u0026gt;Theo Chatbot\u0026lt;/p\u0026gt; \u0026lt;button id=\u0026#34;close_button\u0026#34; onclick=\u0026#34;closeChatbot()\u0026#34; title=\u0026#34;Close Chatbot\u0026#34; style=\u0026#34;position: absolute; right: 10px; color: white\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;twemoji\u0026#34; style=\u0026#34;font-size: 20px\u0026#34;\u0026gt;{% include \u0026#34;.icons/material/close.svg\u0026#34; %} \u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {% endblock %} Replace the source of the chatbot iFrame (https://your-documentation.com/chatbot.html) with the URL of your published custom canvas.\nDownload the following files and add them to your MkDocs project:\nchatbot.css chatbot.js The depicted sample references the chatbot.css and chatbot.js files in the main.html file. Depending on where you place the files in your project, you need to adjust the following lines in the main.html file:\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#39;assets/stylesheets/chatbot.css\u0026#39; | url }}\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;{{ \u0026#39;assets/javascripts/chatbot.js\u0026#39; | url }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Serve or build the project. The button that opens the embedded custom canvas should be displayed at the bottom right corner of the screen. Customize the Chatbot Alter this file to better suit your overall design.\nChange the Text in the Banner To change the text in the chatbot banner, modify the following lines in the main.html file:\n\u0026lt;p style=\u0026#34;font-family: inherit; font-size: 16px; color: white; line-height: 20px; position: absolute; left: 15px;\u0026#34;\u0026gt;Theo Chatbot\u0026lt;/p\u0026gt; Change Color of the Banner To change the color of the chatbot banner, modify the following lines in the chatbot.css file:\n#banner{ position: absolute; top: 0; left: 0; width: 100%; height: 52px; background-color: #ED1A33; align-items: center; display: flex; } Change Color of the \u0026ldquo;Close\u0026rdquo; Button To change the color of the \u0026ldquo;Close\u0026rdquo; button in the chatbot banner, modify the following lines in the chatbot.css file:\n#close_button { position: absolute; right: 10px; color: white; } #close_button:hover { background-color: #891A33; border-color: #891A33; } Change Color of the \u0026ldquo;Open\u0026rdquo; Button To change the color of the \u0026ldquo;Open\u0026rdquo; button in the chatbot banner, modify the following lines in the chatbot.css file:\n#open_button { position: fixed; bottom: 0; right: 0; margin: 20px; cursor: pointer; padding: 10px 20px; /* Adjust padding */ width: 80px; /* Fixed width for both buttons */ height: 80px; /* Adjust height */ border-radius: 40px; /* Rounded corners */ background-color: white; color: #ED1A33; } #open_button:hover { background-color: #891A33; border-color: #891A33; } Change Icon of the \u0026ldquo;Open\u0026rdquo; Button To change the icon of the \u0026ldquo;Open\u0026rdquo; button at the buttom right corner of the page, modify the following lines in the main.html file:\n\u0026lt;span class=\u0026#34;twemoji\u0026#34; style=\u0026#34;font-size: 35px\u0026#34;;\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;fa-beat\u0026#34; style=\u0026#34;margin-top: -5px;\u0026#34;\u0026gt;{% include \u0026#34;.icons/fontawesome/solid/comments.svg\u0026#34; %} \u0026lt;/div\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; ","date":"June 5, 2024","hero":"/posts/integrate-copilot-with-mkdocs/writing.png","permalink":"https://hugo-toha.github.io/posts/integrate-copilot-with-mkdocs/","summary":"In this post I\u0026rsquo;d like to show you how to integrate a custom Microsoft Copilot Studio Chatbot with MkDocs. The goal is to provide a chatbot on all pages of the documentation, that is trained with the content of the documentation, see screenshot.\nAbout this Approach You can connect to a copilot with a custom canvas that is hosted as a standalone web app in your MkDocs project. This option is best if you need to embed a customized iFrame across multiple web pages / documentation pages.","tags":["Microsoft","Chatbot"],"title":"Integrate a MS Copilot Chatbot with MkDocs"},{"categories":null,"contents":"In this post I\u0026rsquo;d like to show you how to use Microsoft Power Automate to generate markdown content for your MkDocs project.\nPower Automate is a cloud-based process automation service that can be used to create automated workflows to synchronize and collect data, get notifications, start approvals, and more.\nAbout this Use Case There are multiple reasons to automate content creation. In our case, we wanted to make it easier for non-developers to publish news in the \u0026ldquo;Latest News\u0026rdquo; section of our HelpCenter, see screenshot below.\nBecause our marketing and support teams are not familiar with gitHub and/or MkDocs, we wanted to give them the opportunity to directly publish content using a SharePoint Online list. Whenever someone adds an item to the SharePoint list or edits an existing item, a Power Automate workflow is triggered that writes the content of the list to a markdown file and publishes the file to gitHub.\nPrerequisites Create an empty markdown file for your generated content in your MkDocs project (e.g., newsfeed.md). Create a Microsoft SharePoint list with all needed input columns (here title, description and date).\nFollow the steps described in Jan Vidar Elven\u0026rsquo;s How to Send Requests to GitHub API from Power Platform using Custom Connector to create an OAuth Application for the Github API and create a Power Automate Custom Connector for the OAuth Application. The depicted example uses markdown syntax that is specific to the Material theme to create grid cards for the SharePoint items. When using a different theme, make sure to adjust the depicted markdown code accordingly. Workflow Add the following actions to your Power Automate workflow:\nCreate a new Power Automate worklow.\nAdd a trigger that runs the workflow whenever your SharePoint list is modified.\nRead out all items of the SharePoint list. During this step we also sort the items based on the Date column of the SharePoint list. Add an Initialize variable action to create a new string variable for the new markdown content (3). To create grid cards, enter the following string as the initial value of the variable:\n\u0026lt;div class=\u0026#34;grid cards\u0026#34; markdown\u0026gt; Add a For each action to loop through all items in the SharePoint.\nAdd a Compose action to create the new markdown content based on the content of the SharePoint list, e.g., items('name_of_the_for_each_action')?['column_name']. The depicted example uses the following string to create a grid card using the Title, Description and Date columns of the current SharePoint item:\n- **items(\u0026#39;Loop_through_all_Items\u0026#39;)?[\u0026#39;Title\u0026#39;]**\r---\ritems(\u0026#39;Loop_through_all_Items\u0026#39;)?[\u0026#39;Description\u0026#39;]\r---\r:material-clock-time-two-outline: items(\u0026#39;Loop_through_all_Items\u0026#39;)?[\u0026#39;Date\u0026#39;] Add an Append to string variable action to append the output of the composed string to the initial string variable created in step 4.\nAdd another Append to string variable action after the loop to add additional markdown content to the end the markdown file. The following string is added to close the list of grid card items:\n\u0026lt;/div\u0026gt; Add a Compose action to parse the content of your string variable to the Base64 format used by gitHub, e.g., base64(variables('variable-name')).\nAdd the gitHub Custom Connector described in Jan Vidar Elven\u0026rsquo;s How to Send Requests to GitHub API from Power Platform using Custom Connector to read the content of the target markdown file in your gitHub repository. This is necessary to get the SHA value of the markdown file that is required to write the new content to the file. Optional: Implement logic to check if the file exists, what to do in case the file is not accessible, etc. Here, we format the content of the existing markdown file from Base64 to string (base64ToString(outputs('name_of_custom_connector')?['body/content'])) and compare the new content with the existing content to see if the file needs to be updated or not (this has to do with the additional SharePoint columns that are not covered in this post).\nAdd the gitHub Custom Connector to overwrite the target markdown file with the new formatted content from step 9. Optional: Add an email notification to get informed, whenever a new item is successfully published to GitHub.\nThe final newsfeed.md file looks like this:\n\u0026lt;div class=\u0026#34;grid cards\u0026#34; markdown\u0026gt;\r- **Welcome to the ERPConnect HelpCenter**\r---\rLooking for something? \u0026lt;br\u0026gt;Try the search bar, our new Theo chatbot or browse our [documentation](documentation/introduction/index.md).\r---\r:material-clock-time-two-outline: 2024-04-01\r- **R3Connection API updated**\r---\rBreaking Changes: \u0026lt;br\u0026gt;Obsolete APIs in the R3Connection class have been removed, see [Release Notes](https://helpcenter.theobald-software.com/release-notes/ERPConnect-7.6.0/).\r---\r:material-clock-time-two-outline: 2023-12-18\r- **RFC Connection via WebSocket added**\r---\rConnect to a single application server or public or private cloud instance via RFC over WebSocket, see [SAP Connection](./documentation/sap-connection/log-on-to-sap.md). ---\r:material-clock-time-two-outline: 2023-12-07\r- **Support for SNC SSO with NWRFC added**\r---\r`R3Connection.GetSSOTicket()` now supports Secure Network Connection with NetWeaver RFC, see [SAP Connection: SSO with SNC](documentation/sap-connection/sso-with-snc.md).\r---\r:material-clock-time-two-outline: 2023-04-05\r\u0026lt;/div\u0026gt; How to use the Generated File You can use the generated markdown file as a single page dedicated news or you can include the content of the file on other pages.\nThe \u0026ldquo;Latest News\u0026rdquo; section on our landing page only shows the first 3 items of the SharePoint list by using the PyMdown Extension: Snippet Lines. Additionally we provide a \u0026ldquo;show more\u0026rdquo; link that opens the complete newsfeed page:\nYou can use the following markdown code to recreate the \u0026ldquo;Latest News\u0026rdquo; section (note that for this to work, at least 3 items must be available in the SharePoint list):\n### Latest News \u0026lt;div class=\u0026#34;grid cards\u0026#34; markdown\u0026gt; \u0026lt;!--- Inject content between line 3 and line 33 of newsfeed.md ~ first 3 grid cards --\u0026gt; --8\u0026lt;-- \u0026#34;newsfeed.md:3:33\u0026#34; \u0026lt;/div\u0026gt; [:octicons-arrow-right-24: Show more](newsfeed.md) Aaand that's it! I hope this was helpful and could inspire someone to do other cool things with Power Automate and MkDocs \u0026#x1f604;.\n","date":"May 7, 2024","hero":"/posts/auto-generate-markdown-content/writing.png","permalink":"https://hugo-toha.github.io/posts/auto-generate-markdown-content/","summary":"In this post I\u0026rsquo;d like to show you how to use Microsoft Power Automate to generate markdown content for your MkDocs project.\nPower Automate is a cloud-based process automation service that can be used to create automated workflows to synchronize and collect data, get notifications, start approvals, and more.\nAbout this Use Case There are multiple reasons to automate content creation. In our case, we wanted to make it easier for non-developers to publish news in the \u0026ldquo;Latest News\u0026rdquo; section of our HelpCenter, see screenshot below.","tags":["Microsoft","Power Automate","Content Creation"],"title":"Generate Markdown Content Using Power Automate"},{"categories":null,"contents":"Our company (or rather I as the technical writer responsible for our documentation) recently decided to say goodbye to our current solution for creating documentation: Jekyll. Instead, we are now working on migrating our existing content to MkDocs.\nIn this post I want to tell you a little bit about the reasons behind this decision.\nStatus Quo Currently, we still use Jekyll 3 to build our documentation.\nJekyll is a static site generator that uses static Markdown files and converts them to a website. The main focus of Jekyll is the creation of websites and blogs. While there are multiple documentation themes available for Jekyll, most of them provide only basic features. This is why an external web-developer was hired to provide additional functionality and a UI that matches our needs. Side note: this all happened before I joined the company.\nWe use Jekyll for 2 Website:\nAn Online Help that covers 8 different products with similar content. A Knowledge Base that covers in-depth articles that involve use cases or 3rd-party-tools. Because a lot of articles apply to multiple products, the Knowledge Base does not explicitly separate between the products. Why change a Running System? After \u0026gt;5 years of writing documentation with Jekyll, the following pain points have caused us to reconsider our approach:\nDated UI Any changes involve an external developer Bad performance (long build time) No analytics implemented The search functionality is a blackbox The search returns results for all products unless a filter is applied, the Knowledge Base does not even have a filter The Knowledge Base does not separate between products Alternatives, Alternatives\u0026hellip; When first discussing options, the continued usage of markdown files in combination with a static site generator was not a requirement. After looking into alternatives, I still went for a static site generator, because I like the flexibility, accessibility and easy setup process they offer.\nSome solutions I looked into:\nPro Con Jekyll 4 Faster than Jekyll 3 Recycling of UI and custom plugins possible Urge to reuse (subpar) layout and functionalities would be too high Hugo Good performance Steep learnign curve Documentation is not the focus (missing functionalities) \u0026ndash;\u0026gt; we\u0026rsquo;d have to build our own UI, no human resources HelpDocs Markdown support Reusable content snippets Search tags We\u0026rsquo;d need a custom layout to cover multiple products\nMigration of existing content would be time consuming. ProProfs Supports multiple sites (single source) Reusable content snippets Limited markdown support (WYSIWYG editor) Search functionality is not clear Migration of existing content would be time consuming. Why MkDocs? MkDocs is a static site generator that is geared towards technical documentation. Like Jekyll, it uses markdown files to create websites. But what makes it more favorable than Jekyll and the other alternatives?\nMkDocs in combination with the Material theme meets our requirements more than any other solution I tested. The requirements (that are the result of a long discussion during a team workshop) are as follows:\nMust-Have-Features:\nModern UI (clear navigation) Search: suggestions, auto-complete, each product has its own search Ability to make small frontent or backend changes in-house (overriding the theme \u0026amp; installation of external plugins to add functionalities) Reusable content snippets: Content must be available in multiple products (macros plugin) Table of content on each page (optional: highlights the active section) Option to combine / put Online Help and Knowledge Base on the same website (again: clear navigation) Nice-to-Have Features\nIntegration with ticket system (jitbit) Community features (comments, time to read, etc.) Tags that add keywords to pages and that can be looked up in the search (we use limited terminology in our documentation for consistency reasons, which unfortunately limits the search functionality for users that use different terms) It should also be noted that the main selling point for MkDocs was the option to install additional plugins / functionalities. That said, the Material theme by squidfunk already provides an extensive list of build-in features and comes with a modern and highly customizable UI.\nOne highlight of the Material theme is the projects plugin, which enables us to manage different products separately from each other.\nMigration from Jekyll to MkDocs After some fundamental planning, we started migrating the shortest product documentation as a PoC. The migration included:\nCreating a new GitHub repository with a new folder structure (e.g., new product folders, fodler for text snippets, etc.). Moving the product relevant markdown files from Online Help and Knowledge Base into the new repository (the Online Help and Knowledge Base are now combined in a single product specific \u0026ldquo;HelpCenter\u0026rdquo;). Adjusting links (internal links to files and images). Customizing UI elements. Adding and testing additional plugins. Getting feedback from colleagues (-\u0026gt; more customization). Setting up GitHub Pages and a custom domain to host the new documentation. Setting up Google Analytics. Marking the old resources as \u0026ldquo;deprecated\u0026rdquo; and announcing the new documentation. At the time of this post, the documentation of the first product has been live for a month. The feedback from colleagues and customers so far has been positive.\nThe plan is to migrate all products until the end of the year (2024).\nAppendix For thos interested: here are some slides of the presentation I used when pitching MkDocs to my team leader:\nPage: / Previous Next ","date":"April 20, 2024","hero":"/posts/jekyll-to-mkdocs-migration/graphics.png","permalink":"https://hugo-toha.github.io/posts/jekyll-to-mkdocs-migration/","summary":"Our company (or rather I as the technical writer responsible for our documentation) recently decided to say goodbye to our current solution for creating documentation: Jekyll. Instead, we are now working on migrating our existing content to MkDocs.\nIn this post I want to tell you a little bit about the reasons behind this decision.\nStatus Quo Currently, we still use Jekyll 3 to build our documentation.\nJekyll is a static site generator that uses static Markdown files and converts them to a website.","tags":["Jekyll","MkDocs","Migration"],"title":"Migrating from Jekyll to MkDocs"},{"categories":["Basic"],"contents":"Hi and welcome to my blog, where I post random stuff that I deal with during my work as a technical writer in a software company.\nMy Role As mentioned above, I work as a technical writer at a software company. When I started this job in 2021, I was a career changer (former application engineer). While I had some experience writing software documentation, I wasn\u0026rsquo;t trained in the field of writing / documenting. Furthermore, I was hired to take over the work of my colleague - an actual technical writer - who started her 2-year parental leave about two weeks before my first day at the company. For these 2 years I was the only technical editor in the company and responsible for all aspects of the documentation, including gathering all kinds of information, optimizing (shortening) the publishing process and writing documentation alongside our agile software developer team.\n","date":"April 19, 2024","hero":"/posts/introduction/desk.jpg","permalink":"https://hugo-toha.github.io/posts/introduction/","summary":"Hi and welcome to my blog, where I post random stuff that I deal with during my work as a technical writer in a software company.\nMy Role As mentioned above, I work as a technical writer at a software company. When I started this job in 2021, I was a career changer (former application engineer). While I had some experience writing software documentation, I wasn\u0026rsquo;t trained in the field of writing / documenting.","tags":["Basic"],"title":"Introduction"},{"categories":null,"contents":"Go Notes ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/go/_index.bn/","summary":"Go Notes ","tags":null,"title":"Go এর নোট সমূহ"},{"categories":null,"contents":"","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/_index.bn/","summary":"","tags":null,"title":"নোট সমূহ"},{"categories":null,"contents":"Bash Notes ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://hugo-toha.github.io/notes/bash/_index.bn/","summary":"Bash Notes ","tags":null,"title":"ব্যাশের নোট সমূহ"}]